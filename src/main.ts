import { app, BrowserWindow, ipcMain } from 'electron';
// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const SECOND_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SECOND_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: true,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
    }
  });

  const secondWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: true,
      preload: SECOND_WINDOW_PRELOAD_WEBPACK_ENTRY
    }
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  secondWindow.loadURL(SECOND_WINDOW_WEBPACK_ENTRY);

  console.log(time);

};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Shared state - written by main window, read by second window

let time = 0;
let osaekomi1 = false;
let osaekomi1_time = 0;
let osaekomi2 = false;
let osaekomi2_time = 0;
let ippon1 = 0;
let ippon2 = 0;
let wazaari1 = 0;
let wazaari2 = 0;
let shido1 = 0;
let shido2 = 0;

// Shared state listeners

ipcMain.on('time', (event, number) => {
  time = number;
});

ipcMain.on('osaekomi1', (event, bool) => {
  osaekomi1 = bool;
});

ipcMain.on('osaekomi1_time', (event, number) => {
  osaekomi1_time = number;
});

ipcMain.on('osaekomi2', (event, bool) => {
  osaekomi2 = bool;
});

ipcMain.on('osaekomi2_time', (event, number) => {
  osaekomi2_time = number;
});

ipcMain.on('ippon1', (event, ippon) => {
  ippon1 = ippon;
});

ipcMain.on('wazaari1', (event, wazaari) => {
  wazaari1 = wazaari;
});

ipcMain.on('shido1', (event, shido) => {
  shido1 = shido;
});

ipcMain.on('ippon2', (event, ippon) => {
  ippon2 = ippon;
});

ipcMain.on('wazaari2', (event, wazaari) => {
  wazaari2 = wazaari;
});

ipcMain.on('shido2', (event, shido) => {
  shido2 = shido;
});

// Reset method
ipcMain.on('reset', () => {
  time = 0;
  osaekomi1 = false;
  osaekomi1_time = 0;
  osaekomi2 = false;
  osaekomi2_time = 0;
  ippon1 = 0;
  ippon2 = 0;
  wazaari1 = 0;
  wazaari2 = 0;
  shido1 = 0;
  shido2 = 0;
});

// Method invoked by the second window to fetch the data
ipcMain.handle('fetch', () => {
  let data: DataBlock = {
    time: time,
    osaekomi1: osaekomi1,
    osaekomi1_time: osaekomi1_time,
    osaekomi2: osaekomi2,
    osaekomi2_time: osaekomi2_time,
    ippon1: ippon1,
    wazaari1: wazaari1,
    shido1: shido1,
    ippon2: ippon2,
    wazaari2: wazaari2,
    shido2: shido2
  }

  return data;
});